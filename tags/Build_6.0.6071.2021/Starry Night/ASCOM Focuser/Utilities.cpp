//========================================================================
//
// TITLE:		UTILITIES.CPP
//
// FACILITY:	StarryNight Plug-In DLL ASCOM focuser Control
//
// ABSTRACT:	
//
// USING:		
//
// ENVIRONMENT:	Microsoft Windows Windows 95/98/NT/2000/XP
//				Developed under Microsoft Visual C++ Version 6.0
//
// AUTHOR:		Robert B. Denny
//
// Edit Log:
//
// When			Who		What
//----------	---		--------------------------------------------------
// 26-Jul-00	rbd		Initial edit
// 21-Aug-05	mk		Additional Modifications to drvFail
//========================================================================
#include "AscomFocuser.h"
#pragma hdrstop


// ---------
// pToCStr() - Convert PString to CString
// ---------
//
void pToCStr(pStr255 p, char *c)
{
	DWORD l = (DWORD)p[0];

	if(l > 0)
		CopyMemory(c, &p[1], l);
	c[l] = '\0';
}

// ---------
// cToPstr() - Convert CString to PString
// ---------
//
void cToPstr(char *c, pStr255 p)
{
	int l = lstrlen(c);

	p[0] = (unsigned char)(l & 0xFF);
	if(p[0] > 0)
		CopyMemory(&p[1], c, l);
}

// ---------
// pStrCmp() - Compare PStrings
// ---------
//
bool pStrCmp(pStr255 s1, pStr255 s2)
{
	if(s1[0] != s2[0])
		return(false);
	for (short i = 1; i <= s1[0]; i++) {
		if(s1[i] != s2[i])
			return(false);
	}
	return(true);
}

// --------------
// ansi_to_bstr() - Convert ANSI to BSTR
// --------------
//
BSTR ansi_to_bstr(char *s)
{
	OLECHAR *os = ansi_to_uni(s);			// Convert to UNI
	BSTR bs = SysAllocString(os);			// Make BSTR

	if(bs == NULL)
	{
		drvFail("Out of memory in BSTR conversion.", NULL, true);
		return NULL;
	}

	free(os);						// Junk work buffer
	return(bs);								// Return BSTR
}


// -------------
// ansi_to_uni() - Convert ANSI to alloc()'ed unicode
// -------------
//
// Convert ANSI to Unicode, return malloc()'ed Unicode string
//
OLECHAR *ansi_to_uni(char *s)
{
	int ol = MultiByteToWideChar(CP_ACP, 0, s, -1, NULL, 0);
	if(0 == ol)
	{
		drvFail("Unicode conversion failed.", NULL, true);
		return NULL;
	}

	OLECHAR *os = (OLECHAR *)malloc((ol + 4) * sizeof(WCHAR));
	if (NULL == os) 
	{
		drvFail("Out of memory in unicode conversion.", NULL, true);
		return NULL;
	}


	if (0 == MultiByteToWideChar(CP_ACP, 0, s, -1, os, ol))
	{
		DWORD dwRes = GetLastError();	// Wiped out by ->Free()
		free(os);
		drvFail("Unicode conversion failed.", NULL, true);
		return NULL;
	}

	os[ol] = WCHAR(0);					// Assure terminated
	return(os);
}


// -------------
// uni_to_ansi() - Convert unicode to ANSI, return pointer to new[]'ed string
// -------------
//
char *uni_to_ansi(OLECHAR *os)
{
	char *cp;

	// Is this the right way??? (it works)
	int len = WideCharToMultiByte(CP_ACP,
								0,
								os, 
								-1, 
								NULL, 
								0, 
								NULL, 
								NULL); 
	cp = new char[len + 5];
	if(cp == NULL)
		drvFail("Out of memory.", NULL, true);
	if (0 == WideCharToMultiByte(CP_ACP, 
									0, 
									os, 
									-1, 
									cp, 
									len, 
									NULL, 
									NULL)) 
	{
		delete [] cp;
		drvFail("Failed to convert unicode to ansi.", NULL, true);
	}

	cp[len] = '\0';
	return(cp);
}


// -------
// drvFail
// -------
//
// Called to display a message box and then generate an exception
// that should be caught for recovery. This handles Error objects
// generated by the Automation object. If there is a live error 
// object and it has a non-empty Description string, then the 
// description string will be the error message. If not, then the
// string passed to us by the caller is the error.
//
void drvFail(char *msg, EXCEPINFO *ei, bool bFatal)
{
	bool handled = false;
	if(bFatal)										// If was a fatal error, 
		TermFocuser();								// shut ourselves down
	if(ei != NULL)
	{
		__try
		{
			char *msg = uni_to_ansi(ei->bstrDescription);
			char *src = uni_to_ansi(ei->bstrSource);
			MessageBox(_hWndMain, msg, src, (MB_OK | MB_ICONSTOP | MB_SETFOREGROUND));
			delete [] msg;
			delete[] src;
			handled = true;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			handled = false;
		}
	}

	if(!handled)
		MessageBox(NULL, msg, _szAlertTitle, (MB_OK & MB_ICONSTOP | MB_SETFOREGROUND));

	if (!bFatal)
		_bFocuserActive = true;

	SetForegroundWindow(_hWndMain);					// Bring ourself to the front
	ABORT;
}